// Operation codes and their method are generated by a macro
opcodes![
  Add << 1,
  Mul << 2,
  Input << 3,
  Output << 4,
  JumpIf << 5,
  JumpUnless << 6,
  IfLess << 7,
  IfEquals << 8,
  SetBase << 9,
  Halt << 99
];

#[derive(Debug)]
enum State {
  // New yet to be readinstruction
  Initial,
  // Opcode and operation modes were read
  Op(Opcode),
  // Opcode, operation modes and at least one parameter were read
  Params { op: Opcode, params: Vec<i128> },
}

#[derive(Debug)]
pub struct Program {
  state: State,
  pointer: usize,
  base: usize,
  heap: Vec<i128>,
  pub stack: Vec<i128>,
  pub inputs: Vec<i128>,
  pub retval: Option<i128>,
  pub paused: bool,
  pub halted: bool,
}

impl Program {
  pub fn new(stack: Vec<i128>, inputs: Vec<i128>) -> Program {
    Program {
      state: State::Initial,
      pointer: 0,
      base: 0,
      heap: vec![],
      stack,
      inputs,
      retval: None,
      paused: true,
      halted: false,
    }
  }

  // Read current instruction
  fn next(&mut self, param: i128) {
    self.state = match self.state {
      // On clean state, the only thing that can be read is an opcode
      State::Initial => State::Op(param.into()),

      // When we get an opcode, the next thing to be read is a param (if applicable)
      State::Op(ref op) => State::Params { op: *op, params: vec![param] },

      // This state is a recursive one, adding new parameters until we get the proper count for the opcode
      State::Params { op, ref params } => {
        let mut params = params.to_vec();
        params.push(param);
        State::Params { op, params }
      }
    };
  }

  // Reset state machine when current instruction is finished
  fn reset(&mut self) {
    self.state = State::Initial;
  }

  // Loop over all instructions in memory until an output is given or the Halt instruction is found
  pub fn execute(&mut self) {
    self.paused = false;
    while !self.halted && !self.paused {
      self.tick()
    }
  }

  pub fn execute_for_output(&mut self) -> Option<i128> {
    self.execute();
    self.retval
  }

  fn tick(&mut self) {
    // Get the instruction under the instruction pointer
    let instruction = if self.stack.len() > self.pointer {
      self.stack[self.pointer]
    } else {
      0
    };

    match self.state {
      State::Initial => self.next(instruction),
      State::Op(Halt(..)) => {
        self.halted = true;
        return;
      }
      State::Op { .. } => self.next(instruction),

      // If we have an opcode, we read its parameters until the branch for the appropriate opcode is satisfied with the number of parameters
      //  * (Op1(m1, m2, m3), &[v1, v2, r]) means that, for the Op1 opcode, we are interested in the three modes of operation and stop reading when we get three parameters
      //  * (Op2(m1, _, _), &[r]) means that, for the Op2 opcode, we are interested in the first mode of operation and stop reading when we have one parameter
      State::Params { op: code, ref params } => match (code, params.as_slice())
      {
        // This should never happen (it is handled at the Op stage)
        (Halt(..), _) => unimplemented!(),

        // Adds the values of `v1` and `v2` into `r`
        (Add(m1, m2, m3), &[v1, v2, r]) => {
          let (v1, v2, r) = (
            self.deref(m1, v1),
            self.deref(m2, v2),
            self.address(m3, r as usize),
          );
          self.set(r, v1 + v2);
          self.reset();
        }

        // Multiplies the values of `v1` and `v2` into `r`
        (Mul(m1, m2, m3), &[v1, v2, r]) => {
          let (v1, v2, r) = (
            self.deref(m1, v1),
            self.deref(m2, v2),
            self.address(m3, r as usize),
          );
          self.set(r, v1 * v2);
          self.reset();
        }

        // Requests an input value from the input queue. Once consumed, the input is removed from the queue
        (Input(m1, ..), &[r]) => {
          // A program should always be provided with enough inputs to function properly
          if self.inputs.is_empty() {
            panic!("not enough inputs");
          }
          let r = self.address(m1, r as usize);
          let v = self.inputs.remove(0);
          self.set(r, v);
          self.reset();
        }

        // Outputs a result value. The program is paused (but keeps its state), until resumed
        (Output(m, ..), &[v]) => {
          self.paused = true;
          self.retval = Some(self.deref(m, v));
          self.reset();
          return;
        }

        // If `cond` is different than zero, change the instruction pointer to `address`
        (JumpIf(m1, m2, _), &[cond, address]) => {
          if self.deref(m1, cond) != 0 {
            self.pointer = self.deref(m2, address) as usize;
          }
          self.reset();
        }
        // If `cond` equals zero, change the instruction pointer to `address`
        (JumpUnless(m1, m2, _), &[cond, address]) => {
          if self.deref(m1, cond) == 0 {
            self.pointer = self.deref(m2, address) as usize;
          }
          self.reset();
        }
        // If `v1` is less than `v2`, write `0` to `address`, else, write `1`
        (IfLess(m1, m2, m3), &[v1, v2, r]) => {
          let r = self.address(m3, r as usize);
          if self.deref(m1, v1) < self.deref(m2, v2) {
            self.set(r, 1);
          } else {
            self.set(r, 0);
          }
          self.reset();
        }
        // If `v1` equals `v2`, write `1` to `address`, else, write `0`
        (IfEquals(m1, m2, m3), &[v1, v2, r]) => {
          let r = self.address(m3, r as usize);
          if self.deref(m1, v1) == self.deref(m2, v2) {
            self.set(r, 1);
          } else {
            self.set(r, 0);
          }
          self.reset();
        }

        // Set the offset base to `v1`
        (SetBase(m1, ..), &[v1]) => {
          self.base = (self.base as i128 + self.deref(m1, v1)) as usize;
          self.reset();
        }

        // We are missing some parameters for the current opcode, continue reading instructions
        _ => self.next(instruction),
      },
    }

    // Advance the instruction pointer, except when we are in a new instruction
    if let State::Initial = self.state {
    } else {
      self.pointer += 1;
    }
  }

  // Return a value in memory, according to the current mode of operation
  //  * Mode::Position returns the memory at address `value`
  //  * Mode::Immediate returns the value itself
  //  * Mode::Relative returns the memory at address `value`, offset by the current value of the base
  fn deref(&mut self, mode: Mode, value: i128) -> i128 {
    match mode {
      Mode::Position => self.get(value as usize),
      Mode::Immediate => value,
      Mode::Relative => self.get((self.base as i128 + value) as usize),
    }
  }

  // Return a memory address, possibly offset by the base if in Mode::Relative mode.
  fn address(&self, mode: Mode, address: usize) -> usize {
    match mode {
      Mode::Position => address,
      Mode::Relative => (self.base as i128 + address as i128) as usize,
      _ => panic!("cannot write with mode immediate"),
    }
  }

  // Returns the memory at the provided address
  // If the memory index exceeds the main memory size, it means we are looking at an extended memory address, in the heap
  fn get(&mut self, address: usize) -> i128 {
    if address >= self.stack.len() {
      let offset = address as usize - self.stack.len() + 1;

      // The heap starts empty, if we are trying to write to a non-existing chunk of memory, we first need to extend the heap to accomodate for this new value
      if offset > self.heap.len() {
        self.heap.resize_with(offset, Default::default);
      }

      self.heap[offset - 1]
    } else {
      self.stack[address]
    }
  }

  // Writes a value to memory at the provided address
  // If the memory index exceeds the main memory size, it means we are looking at an extended memory address, in the heap
  fn set(&mut self, address: usize, value: i128) {
    if address >= self.stack.len() {
      let offset = address as usize - self.stack.len() + 1;

      if offset > self.heap.len() {
        self.heap.resize_with(offset, Default::default);
      }

      self.heap[offset - 1] = value;
    } else {
      self.stack[address] = value;
    }
  }
}
